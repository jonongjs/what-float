<!DOCTYPE html>
<html lang="en">
	<head>
		<title>What's in a Float?</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Roboto+Mono&display=swap" rel="stylesheet">
		<style>
:root {
	--reddish: #fb015b;
	--yellowish: #fef7e0;
	--greenish: #41ba63;
	--bluish: #00b9f1;
}

* {
	margin: 0;
	padding: 0;
}

html, body {
	height: 100%;
	width: 100%;
	overscroll-behavior: none;

	position: fixed;

	color: white;
	background-color: black;
	text-align: center;

	font-family: 'Lato', sans-serif;
}

slide {
	display: block;
	position: absolute;
	width: 100vmin;
	height: 100vmin;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	box-sizing: border-box;

	background-color: black;
	text-align: left;
	padding: 5px 10px;
	font-size: 5vmin;

	visibility: hidden;
}

#title h1 {
	position: absolute;
	top: 50%;
	transform: translateY(-50%);

	width: 100%;
	text-align: center;

	font-size: 2em;
}

slide h2 {
	padding-bottom: 0.5em;
	font-size: 1.5em;
}

bit-field {
	display: block;
	width: 100%;
}

.click-in {
	visibility: hidden;
}

.show {
	visibility: visible;
}

ul {
	list-style: square inside;
}
li ul {
	list-style: circle inside;
	margin-left: 1em;
}

pre {
	display: inline-block;
	background-color: var(--yellowish);
	color: black;
	border: 2px solid var(--reddish);
	border-radius: 4px;
}

.mono {
	font-family: 'Roboto Mono', monospace;
	font-size: 0.9em;
}
		</style>

	</head>
	<body>

		<slide id="title" class="show">
			<h1>What's in a Float?</h1>
		</slide>

		<slide id="intro">
			<h2>Background</h2>
			<ul>
				<li class="click-in">Floating point calculations are commonly used, but do we know where the pitfalls are?</li>
			</ul>
		</slide>

		<slide id="quiz">
			<h2>Quiz</h2>
			<ul>
				<li class="click-in">What's a floating point number?</li>
				<li class="click-in">What's the result of <pre class=mono>0.1 + 0.2 == 0.3</pre>?</li>
				<li class="click-in">Again, what's a floating point number?</li>
			</ul>
		</slide>

		<slide id="fixedpt">
			<h2>Fixed Point</h2>
			<ul>
				<li class="click-in">Finite precision</li>
			</ul>
		</slide>

		<slide id="floatingpt">
			<h2>Floating Point</h2>
			<ul>
				<li class="click-in">Most common standard: IEEE 754</li>
				<li class="click-in">Definition:</li>
				<li class="click-in">Special values:</li>
			</ul>
		</slide>

		<slide id="deeper">
			<h2>Looking Deeper</h2>
			<div id=inspector>
				<label for=inspector-input class=no-advance>Input:</label>
				<input id=inspector-input type=text class=no-advance value=0>
				<bit-field id=inspector-bits
					data-sign-bits=1
					data-exponent-bits=8
					data-significand-bits=23
					data-value=0
					class=no-advance
				>
				</bit-field>
				<script>
					document.getElementById('inspector-input')
						.addEventListener('input', function(evt) {
							document.getElementById('inspector-bits')
								.setAttribute('data-value', evt.target.value);
						});
					document.getElementById('inspector-bits')
						.addEventListener('valueUpdate', function(evt) {
							const value = evt.detail.value;
							let displayValue = value.toString();
							// hack for -0
							if (Object.is(-0, value)) {
								displayValue = '-0';
							}
							document.getElementById('inspector-input')
								.value = displayValue;
						});
				</script>
			</div>
		</slide>

		<slide id="takeaway">
			<h2>Key takeaways</h2>
			<ul>
				<li class="click-in">Finite precision</li>
			</ul>
		</slide>

		<slide id="fin">
			<h2>Fin.</h2>
			<ul>
				<li>References
					<ul>
						<li><a href="https://ciechanow.ski/exposing-floating-point/">Exposing Floating Point</a></li>
						<li><a href="https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/">Examples of floating point problems</a></li>
						<li><a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a></li>
					</ul>
				</li>
			</ul>
			<ul>
				<li>Exploration
					<ul>
						<li><a href="https://float.exposed/">float.exposed</a></li>
					</ul>
				</li>
			</ul>
		</slide>

		<script>
			const slides = Array.from(
				document.querySelectorAll('slide').values()
			).map((elt) => elt.id);

			let currentSlideIdx = 0;

			/**
			 * @param {string} slideId
			 * @param {boolean} [showAll]
			 */
			function goToSlide(slideId, showAll) {
				currentSlideIdx = Math.max(0, slides.indexOf(slideId));
				document.querySelectorAll('slide').forEach((elt, idx) => {
					if (idx <= currentSlideIdx) {
						elt.classList.add('show');
					} else {
						elt.classList.remove('show');
					}

					elt.querySelectorAll('.click-in').forEach((subElt) => {
						const toShow = (idx < currentSlideIdx) || (idx == currentSlideIdx && showAll);
						if (toShow) {
							subElt.classList.add('show');
						} else {
							subElt.classList.remove('show');
						}
					});
				});
			}

			function goToNext() {
				// check that we've gone through all items on this slide
				const slide = document.querySelectorAll('slide')[currentSlideIdx];
				const allItems = slide.querySelectorAll('.click-in');
				const shownItems = slide.querySelectorAll('.click-in.show');
				if (shownItems.length < allItems.length) {
					// we haven't shown all items yet, so show the next one
					allItems[shownItems.length].classList.add('show');
				} else {
					// move on to the next slide if possible
					if (currentSlideIdx < slides.length - 1) {
						const newSlideId = slides[currentSlideIdx + 1];

						//NOTE: hashchange will not be fired from history.pushState()
						history.pushState({}, '', '#' + newSlideId);

						// hashchange event does not get fired from history.pushState(),
						// so we have to set the slide manually
						goToSlide(newSlideId);
					}
				}
			}

			function goToPrev() {
				// check that we still have some items to clear out
				const slide = document.querySelectorAll('slide')[currentSlideIdx];
				const allItems = slide.querySelectorAll('.click-in');
				const shownItems = slide.querySelectorAll('.click-in.show');
				if (shownItems.length > 0) {
					// we haven't cleared out all items yet, so hide the earlier one
					allItems[shownItems.length - 1].classList.remove('show');
				} else {
					// move back to the prev slide if possible
					if (currentSlideIdx > 0) {
						const newSlideId = slides[currentSlideIdx - 1];

						//NOTE: hashchange will not be fired from history.pushState()
						history.pushState({}, '', '#' + newSlideId);

						// hashchange event does not get fired from history.pushState(),
						// so we have to set the slide manually
						goToSlide(newSlideId, true);
					}
				}
			}

			// navigation controls

			window.addEventListener('popstate', function (evt) {
				const slideId = location.hash?.substring(1);
				goToSlide(slideId);
			});

			window.addEventListener('keydown', function (evt) {
				if (evt.defaultPrevented) {
					return; // do nothing if the event was already processed
				}

				// only continue with slideshow if we are not in some input
				if (!evt.target.classList.contains('no-advance')) {
					switch (evt.key) {
						case 'ArrowRight':
							goToNext();
							break;

						case 'ArrowLeft':
							goToPrev();
							break;
					}
				}
			});

			window.addEventListener('pointerdown', function (evt) {
				if (evt.target.classList.contains('no-advance')) {
					evt.stopPropagation();
				} else {
					goToNext();
				}
			});

			// force the current slide based on URL
			goToSlide(location.hash?.substring(1));

			// custom element for bit fields
			class BitField extends HTMLElement {
				constructor() {
					super();

					this.buffer = new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT);
					this.byteView = new Uint8Array(this.buffer);
					this.float32Array = new Float32Array(this.buffer);

					this.attachShadow({mode: 'open'});
				}

				connectedCallback() {
					const self = this;
					const shadow = this.shadowRoot;

					const root = document.createElement('div');
					root.classList.add('root');

					const numSignBits = this.hasAttribute('data-sign-bits')
						? parseInt(this.getAttribute('data-sign-bits'), 10)
						: 1;

					const numExponentBits = this.hasAttribute('data-exponent-bits')
						? parseInt(this.getAttribute('data-exponent-bits'), 10)
						: 1;

					const numSignificandBits = this.hasAttribute('data-significand-bits')
						? parseInt(this.getAttribute('data-significand-bits'), 10)
						: 1;

					function makeSection(className, numBits) {
						const div = document.createElement('div');
						div.classList.add('section', className);
						for (let i=0; i<numBits; ++i) {
							const input = document.createElement('div');
							input.classList.add('bit');
							input.textContent = '0';
							div.appendChild(input);

							input.addEventListener('click', function(evt) {
								if (input.textContent == '1') {
									input.textContent = '0';
								} else {
									input.textContent = '1';
								}

								const newFloat = self.reverseBits();

								// update input by custom event
								const customEvent = new CustomEvent('valueUpdate', {
									detail: {
										value: newFloat
									}
								});
								self.dispatchEvent(customEvent);
							});
						}
						return div;
					}

					const signDiv = makeSection('sign-bits', numSignBits);
					const exponentDiv = makeSection('exponent-bits', numExponentBits);
					const significandDiv = makeSection('significand-bits', numSignificandBits);

					root.append(signDiv, exponentDiv, significandDiv);

					// style the content
					const style = document.createElement("style");
					style.textContent = `
.root {
	display: block;
	width: 100%;
	border: 1px solid black;
	font-family: 'Roboto Mono', monospace;
}

.section {
	display: inline-block;
	margin-right: 5px;
	line-height: 0.7em;
	padding: 1px;
	border: 1px transparent solid;
	border-radius: 2px;
}
.section div {
	display: inline-block;
	border: 1px solid black;
	margin: 0;
	font-size: 0.7em;
}

.sign-bits {
	background-color: var(--reddish);
}

.exponent-bits {
	background-color: var(--greenish);
}

.significand-bits {
	background-color: var(--bluish);
}
`;

					shadow.append(style, root);
				}

				static get observedAttributes() {
					return ['data-value'];
				}

				attributeChangedCallback(name, oldValue, newValue) {
					if (name == 'data-value') {
						const newFloat = parseFloat(newValue);
						if (!isNaN(newValue) && oldValue != newValue) {
							this.replaceBits(newFloat);
						}
					}
				}

				replaceBits(v) {
					this.float32Array[0] = v;
					const bits = Array.from(this.shadowRoot.querySelectorAll('.bit'))
						.reverse();
					if (bits.length == 0) {
						return;
					}

					let bitIdx = 0;
					for (let b of this.byteView) {
						for (let i = 0; i < 8; ++i) {
							const bitValue = b & 1;
							bits[bitIdx].textContent = bitValue.toString();
							b = b >> 1;
							++bitIdx;
						}
					}
				}

				reverseBits(v) {
					const bits = Array.from(this.shadowRoot.querySelectorAll('.bit'));
					if (bits.length == 0) {
						return;
					}

					let bitIdx = 0;
					for (let byteIdx = this.byteView.byteLength - 1; byteIdx >= 0; --byteIdx) {
						let byteValue = 0;
						for (let i=0; i<8; ++i) {
							const bitText = bits[bitIdx].textContent;
							const bitValue = bitText == '1' ? 1 : 0;
							byteValue = byteValue | bitValue;
						   if (i < 7) {
							   byteValue = byteValue << 1;
						   }
							++bitIdx;
						}
						this.byteView[byteIdx] = byteValue;
					}

					return this.float32Array[0];
				}
			}

			// Define the new element
			customElements.define('bit-field', BitField);
		</script>
	</body>
</html>
